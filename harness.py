

def esc_tex(s: str) -> str:
    """Minimal TeX escaping for table cells (keeps TeX macros intact; avoids double-escaping)."""
    if s is None:
        return ""
    s = str(s)
    # Normalize a few common Unicode math symbols to TeX
    s = s.replace("≥", r"$\geq$")
    s = s.replace("≠", r"$\neq$")
    # Escape only when not already escaped
    import re
    s = re.sub(r"(?<!\\)&", r"\&", s)
    s = re.sub(r"(?<!\\)%", r"\%", s)
    s = re.sub(r"(?<!\\)#", r"\#", s)
    s = re.sub(r"(?<!\\)_", r"\_", s)
    return s



#!/usr/bin/env python3
import sys
try:
    import yaml
except Exception:
    print("[ERROR] This script requires PyYAML. Install with: pip install pyyaml")
    sys.exit(1)




REQUIRED_TOP = ["version", "packages"]
REQUIRED_PKG = ["id", "name", "gates_closed", "scope", "hypotheses", "outputs", "normalization", "citations"]

def die(msg):
    print(f"[ERROR] {msg}")
    sys.exit(1)

def warn(msg):
    print(f"[WARN] {msg}")

def ok(msg):
    print(f"[OK] {msg}")

def validate_registry(data):
    for k in REQUIRED_TOP:
        if k not in data:
            die(f"Registry missing top-level key: {k}")
    if not isinstance(data["packages"], list) or not data["packages"]:
        die("Registry 'packages' must be a non-empty list")

    ids = set()
    for i, pkg in enumerate(data["packages"], start=1):
        for k in REQUIRED_PKG:
            if k not in pkg:
                die(f"Package #{i} missing key: {k}")
        if pkg["id"] in ids:
            die(f"Duplicate package id: {pkg['id']}")
        ids.add(pkg["id"])

        norm = pkg.get("normalization", {})
        if "lambda_trans" not in norm:
            warn(f"{pkg['id']}: normalization.lambda_trans is missing (handshake may be unclear)")

        if any(("A0_m" in g) or ("Index" in g) for g in pkg.get("gates_closed", [])):
            for nk in ["period", "torsion", "tamagawa"]:
                if nk not in norm:
                    warn(f"{pkg['id']}: normalization.{nk} not declared (needed for visible-factor alignment)")

    ok(f"Validated {len(data['packages'])} package(s).")

def report(data):
    print("\n=== AFU Package Report ===")
    for pkg in data["packages"]:
        print(f"\n- {pkg['id']}: {pkg['name']}")
        print(f"  Gates closed: {', '.join(pkg['gates_closed'])}")
        ar = pkg.get("scope", {}).get("analytic_rank", "?")
        pr = pkg.get("scope", {}).get("p_regime", "?")
        print(f"  Scope: analytic_rank={ar}; p_regime={pr}")
        print("  Outputs:")
        for out in pkg.get("outputs", []):
            print(f"    * {out}")


def tex_escape(s: str) -> str:
    # Minimal TeX escaping for table cells (output is intended to be pasted into LaTeX)
    if s is None:
        return ""
    s = str(s)
    repl = {
        "\\": r"\textbackslash{}",
        "&": r"\&",
        "%": r"\%",
        "$": r"\$",
        "#": r"\#",
        "_": r"\_",
        "{": r"\{",
        "}": r"\}",
        "~": r"\textasciitilde{}",
        "^": r"\textasciicircum{}",
    }
    return "".join(repl.get(ch, ch) for ch in s)




def short_scope(scope: dict) -> str:
    parts = []
    if isinstance(scope, dict):
        if "analytic_rank" in scope:
            parts.append(f"r_an={scope.get('analytic_rank')}")
        if "p_regime" in scope:
            parts.append(f"p: {scope.get('p_regime')}")
        if "reduction" in scope:
            parts.append(f"red: {scope.get('reduction')}")
        if "default_inclusion" in scope:
            parts.append(f"[{scope.get('default_inclusion')}]")
    return "; ".join(parts)

def emit_tex(data: dict, outdir: str) -> None:
    """Emit two LaTeX snippets:
    - AFU_registry_table.tex (one-page-ish table)
    - AFU_translation_dictionary.tex (normalization handshake)
    """
    import os
    os.makedirs(outdir, exist_ok=True)

    pkgs = data.get("packages", [])

    # 1) Registry table
    lines = []
    lines.append("% Auto-generated by harness.py emit-tex")
    lines.append("% Requires: \\usepackage{tabularx}")
    lines.append(r"\footnotesize")
    lines.append(r"\begin{tabularx}{\textwidth}{p{0.12\textwidth} p{0.14\textwidth} X X p{0.18\textwidth}}")
    lines.append(r"\hline")
    lines.append(r"ID & Gates closed & Scope & Hypotheses (minimal) & I/U + W(gate) hooks\\\\")
    lines.append(r"\hline")
    for pkg in pkgs:
        pid = tex_escape(pkg.get("id", ""))
        gates = tex_escape(", ".join(pkg.get("gates_closed", [])))
        gates = esc_tex(gates)
        scope = tex_escape(short_scope(pkg.get("scope", {})))
        scope = esc_tex(scope)
        hyps = pkg.get("hypotheses", []) or []
        hyps_s = "; ".join(hyps[:3]) + ("; ..." if len(hyps) > 3 else "")
        hyps_s = tex_escape(hyps_s)
        doc_i = pkg.get('doc_hook_import')
        doc_u = pkg.get('doc_hook_use')
        if doc_i and doc_u:
            # Compact dual hook: I:/U: with a line break inside the cell.
            doc = f"I: {doc_i}\\newline U: {doc_u}"
        else:
            doc = pkg.get('doc_hook', r'\\Cref{sec:AFU}')
        lines.append(f"{pid} & {gates} & {scope} & {hyps_s} & {doc}\\\\")
    lines.append(r"\hline")
    lines.append(r"\end{tabularx}")
    lines.append(r"\normalsize")
    with open(os.path.join(outdir, "AFU_registry_table.tex"), "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")

    # 2) Translation dictionary
    lines = []
    lines.append("% Auto-generated by harness.py emit-tex")
    lines.append("% Requires: \\usepackage{tabularx}")
    lines.append(r"\footnotesize")
    lines.append(r"\begin{tabularx}{\textwidth}{p{0.18\textwidth} X}")
    lines.append(r"\hline")

    lines.append(r"Package & Normalization / translation notes\\\\")
    lines.append(r"\hline")
    for pkg in pkgs:
        pid = tex_escape(pkg.get("id", ""))
        norm = pkg.get("normalization", {}) or {}
        parts = []
        for k in ["period", "torsion", "tamagawa", "lambda_trans", "notes"]:
            v = norm.get(k)
            if v:
                parts.append(f"{k}: {v}")
        cell = tex_escape("; ".join(parts))
        lines.append(f"{pid} & {cell}\\\\")
    lines.append(r"\hline")
    lines.append(r"\end{tabularx}")
    lines.append(r"\normalsize")
    with open(os.path.join(outdir, "AFU_translation_dictionary.tex"), "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")
    # Extra snippets
    emit_tex_dyadic(data, outdir)
    emit_tex_normalization_stack(data, outdir)


def main():
    argv = sys.argv[1:]
    if len(argv) == 1:
        # Backwards compatible: harness.py <afu_registry.yaml>
        path = argv[0]
        with open(path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)
        validate_registry(data)
        report(data)
        return

    if len(argv) >= 2 and argv[0] in ("validate", "report"):
        cmd, path = argv[0], argv[1]
        with open(path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)
        validate_registry(data)
        if cmd == "report":
            report(data)
        else:
            print("[OK] registry validates")
        return

    if len(argv) >= 3 and argv[0] in ("emit-tex", "emit_tex"):
        _, path, outdir = argv[0], argv[1], argv[2]
        with open(path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)
        validate_registry(data)
        emit_tex(data, outdir)
        print(f"[OK] wrote LaTeX snippets to: {outdir}")
        return

    die("Usage:\n"
        "  harness.py <afu_registry.yaml>\n"
        "  harness.py validate <afu_registry.yaml>\n"
        "  harness.py report <afu_registry.yaml>\n"
        "  harness.py emit-tex <afu_registry.yaml> <outdir>")


def emit_tex_dyadic(data, outdir):
    """
    Emit a LaTeX snippet that enforces the dyadic scope-switch in the paper.
    """
    import os
    pol = data.get("dyadic_policy", {})
    default_scope = pol.get("default", "p odd only (p != 2)")
    opt_pkg = pol.get("opt_in_package", "D2_DYADIC_LOCAL")

    snippet = r"""% Auto-generated by AFU harness (dyadic scope-switch)
\newif\ifdyadic
% Default: DYADIC OFF
\dyadicfalse

% Scope line (use in Introduction/Scope):
%   Default: results for all odd primes p (p \neq 2).
%   If \dyadictrue is set, include p=2 under the local package: """ + opt_pkg + r"""
"""
    path = os.path.join(outdir, "AFU_DYADIC_SCOPE.tex")
    with open(path, "w", encoding="utf-8") as f:
        f.write(snippet)


def emit_tex_normalization_stack(data, outdir):
    """
    Emit a LaTeX snippet describing the normalization stack:
      lambda_trans(total) = lambda_trans(period) * lambda_trans(vis) * lambda_trans(local)
    together with the policy knobs (default/upgrade).
    """
    import os
    # policies are optional
    vf = data.get("visible_factors_policy", {})
    lc = data.get("local_conditions_policy", {})
    dy = data.get("dyadic_policy", {})

    vf_default = vf.get("default", "use V0_TAM_TORS_TRANSLATION; upgrade to V1_TAM_TORS_MATCHING")
    lc_default = lc.get("default", "use L0_LOCAL_TRANSLATION; upgrade to L1_LOCAL_MATCHING")
    dy_default = dy.get("default", "p odd only (p != 2)")
    dy_opt = dy.get("opt_in_package", "D2_DYADIC_LOCAL")

    snippet = r"""% Auto-generated by AFU harness: Normalization stack (lambda_trans)
\begin{center}
\begin{tabular}{p{0.22\linewidth} p{0.72\linewidth}}
\textbf{Normalization stack} &
We decompose the total translation scalar as
\[
\lambda_{\mathrm{trans}}^{\mathrm{total}}
=
\lambda_{\mathrm{trans}}^{\mathrm{period}}
\cdot
\lambda_{\mathrm{trans}}^{\mathrm{vis}}
\cdot
\lambda_{\mathrm{trans}}^{\mathrm{local}}.
\]
\\[2mm]
\textbf{Period module (C*)} &
$\lambda_{\mathrm{trans}}^{\mathrm{period}}$ is governed by the Manin/period scaling layer (C0$\to$C1$\to$C2).\\
\textbf{Visible module (V*)} &
$\lambda_{\mathrm{trans}}^{\mathrm{vis}}$ captures Tamagawa+torsion convention alignment (V0$\to$V1).\\
\textbf{Local module (L*)} &
$\lambda_{\mathrm{trans}}^{\mathrm{local}}$ captures local Selmer-condition convention alignment (L0$\to$L1).\\[2mm]
\textbf{Default policies} &
Period: use C0 unless upgraded to C1/C2.\newline
Visible: """ + vf_default.replace("_", r"\_") + r""".\newline
Local: """ + lc_default.replace("_", r"\_") + r""".\\[1mm]
\textbf{Dyadic scope} &
Default: """ + dy_default.replace("_", r"\_") + r""".\newline
Opt-in: include $p=2$ only with package """ + dy_opt.replace("_", r"\_") + r""".\\
\end{tabular}
\end{center}
"""
    path = os.path.join(outdir, "AFU_NORMALIZATION_STACK.tex")
    with open(path, "w", encoding="utf-8") as f:
        f.write(snippet)

if __name__ == '__main__':
    main()
